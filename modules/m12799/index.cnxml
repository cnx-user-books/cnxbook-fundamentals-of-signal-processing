<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:md="http://cnx.rice.edu/mdml">
  <title>Parks-McClellan FIR Filter Design</title>
  <metadata><md:content-id>undefined</md:content-id><md:title/><md:uuid>0bb211fb-4a74-4efc-8a90-291cef969b75</md:uuid>
</metadata>

  <content>
    <para id="para1">The approximation tolerances for a filter are very often given
    in terms of the maximum, or worst-case, deviation within
    frequency bands.  For example, we
    might wish a lowpass filter in a (16-bit) CD player to have no
    more than
      <m:math>
	<m:apply>
	  <m:divide/>
	  <m:cn>1</m:cn>
	  <m:cn>2</m:cn>
	</m:apply>
      </m:math>-bit deviation in the pass and stop bands.
    </para>   
    <para id="para2"><m:math display="block">
	<m:apply>
	  <m:eq/>
	  <m:apply>
	    <m:ci type="fn">H</m:ci>
	    <m:ci>ω</m:ci>
	  </m:apply>
	  <m:piecewise>
	    <m:piece>
	      <m:apply>
		<m:leq/>
		<m:apply>
		  <m:minus/>
		  <m:cn>1</m:cn>
		  <m:apply>
		    <m:divide/>
		    <m:cn>1</m:cn>
		    <m:apply>
		      <m:power/>
		      <m:cn>2</m:cn>
		      <m:cn>17</m:cn>
		    </m:apply>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:abs/>
		  <m:apply>
		    <m:ci type="fn">H</m:ci>
		    <m:ci>ω</m:ci>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:plus/>
		  <m:cn>1</m:cn>
		  <m:apply>
		    <m:divide/>
		    <m:cn>1</m:cn>
		    <m:apply>
		      <m:power/>
		      <m:cn>2</m:cn>
		      <m:cn>17</m:cn>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:leq/>
		<m:apply>
		  <m:abs/>
		  <m:ci>ω</m:ci>
		</m:apply>
		<m:ci>
		  <m:msub>
		    <m:mi>ω</m:mi>
		    <m:mi>p</m:mi>
		  </m:msub>
		</m:ci>
	      </m:apply>
	    </m:piece>
	    <m:piece>
	      <m:apply>
		<m:geq/>
		<m:apply>
		  <m:divide/>
		  <m:cn>1</m:cn>
		  <m:apply>
		    <m:power/>
		    <m:cn>2</m:cn>
		    <m:cn>17</m:cn>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:abs/>
		  <m:apply>
		    <m:ci type="fn">H</m:ci>
		    <m:ci>ω</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:leq/>
		<m:ci>
		  <m:msub>
		    <m:mi>ω</m:mi>
		    <m:mi>s</m:mi>
		  </m:msub>
		</m:ci>
		<m:apply>
		  <m:abs/>
		  <m:ci>ω</m:ci>
		</m:apply>
		<m:pi/>
	      </m:apply>
	    </m:piece>
	  </m:piecewise>
	</m:apply>
      </m:math>
    </para>
    <para id="para3">The Parks-McClellan filter design method efficiently designs
      linear-phase FIR filters that are optimal in terms of worst-case
      (minimax) error.
      Typically, we would like to have the shortest-length filter
      achieving these specifications.
      Figure <link target-id="fig1"/> illustrates the amplitude frequency
      response of such a filter.
    </para>

    <figure id="fig1">
	<media id="idp10290320" alt=""><image src="../../media/fig1.png" mime-type="image/png"/><image for="pdf" src="../../media/fig1.eps" mime-type="application/postscript"/></media>
        <caption>The black boxes on the left and right are the passbands, the black boxes in the middle represent the stop band, and the space between
        the boxes are the transition bands. Note that
        overshoots may be allowed in the transition bands.</caption>
    </figure>

    <exercise id="exer1"><problem id="idp13478800">
	<para id="para4">
	  Must there be a transition band?
	</para>
      </problem>
    
      <solution id="idp12623024">
        <para id="parasol1">
          Yes, when the desired response is discontinuous.
          Since the frequency response of a finite-length filter
          must be continuous, without a transition band the worst-case
          error could be no less than half the discontinuity.
        </para>
      </solution></exercise>
    <section id="section1">
      <title>Formal Statement of the 
	<!--<m:math>
	  <m:apply>
	    <m:csymbol
	    definitionURL='http://cnx.rice.edu/cd/cnxmath.ocd#norm'/>
	    <m:domainofapplication>
	      <m:infinity/>
	    </m:domainofapplication>
	    <m:ci>L</m:ci>
	  </m:apply>
	</m:math>-->L-∞ (Minimax) Design Problem
      </title>
      <para id="para5">
	For a given filter length (<m:math><m:ci>M</m:ci></m:math>) and
	type (odd length, symmetric, linear phase, for example), and a
	relative error weighting function
	<m:math>
	  <m:apply>
	    <m:ci type="fn">W</m:ci>
	    <m:ci>ω</m:ci>
	  </m:apply>
	</m:math>, find the filter coefficients minimizing the maximum
	error
	<m:math display="block">
	  <m:apply>
	    <m:eq/>
	    <m:apply>
	      <m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#argmin"/>
	      <m:domainofapplication>
		<m:ci type="vector">h</m:ci>
	      </m:domainofapplication>
	      <m:apply>
		<m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#argmax"/>
		<m:domainofapplication>
		  <m:apply>
		    <m:in/>
		    <m:ci>ω</m:ci>
		    <m:ci type="set">F</m:ci>
		  </m:apply>
		</m:domainofapplication>
		<m:apply>
		  <m:abs/>
		  <m:apply>
		    <m:ci type="fn">E</m:ci>
		    <m:ci>ω</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	    <m:apply>
	      <m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#argmin"/>
	      <m:domainofapplication>
		<m:ci type="vector">h</m:ci>
	      </m:domainofapplication>
	      <m:apply>
		<m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#norm"/>
		<m:domainofapplication>
		  <m:infinity/>
		</m:domainofapplication>
		<m:apply>
		  <m:ci type="fn">E</m:ci>
		  <m:ci>ω</m:ci>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:math> where
	<m:math display="block">
	  <m:apply>
	    <m:eq/>
	    <m:apply>
	      <m:ci type="fn">E</m:ci>
	      <m:ci>ω</m:ci>
	    </m:apply>
	    <m:apply>
	      <m:times/>
	      <m:apply>
		<m:ci type="fn">W</m:ci>
		<m:ci>ω</m:ci>
	      </m:apply>
	      <m:apply>
		<m:minus/>
		<m:apply>
		  <m:ci type="fn">
		    <m:msub>
		      <m:mi>H</m:mi>
		      <m:mi>d</m:mi>
		    </m:msub>
		  </m:ci>
		  <m:ci>ω</m:ci>
		</m:apply>
		<m:apply>
		  <m:ci type="fn">H</m:ci>
		  <m:ci>ω</m:ci>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:math>
	and <m:math><m:ci type="set">F</m:ci></m:math> is a compact
	subset of 
	<m:math>
	  <m:apply>
	    <m:in/>
	    <m:ci>ω</m:ci>
	    <m:interval closure="closed-closed">
	      <m:cn>0</m:cn>
	      <m:pi/>
	    </m:interval>
	  </m:apply>
	</m:math> (<foreign>i.e.</foreign>, all <m:math><m:ci>ω</m:ci></m:math> in
	the passbands and stop bands).
      <note id="idp11731920">
	Typically, we would often rather specify 
	<m:math>
	  <m:apply>
	    <m:leq/>
	    <m:apply>
	      <m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#norm"/>
	      <m:domainofapplication>
		<m:infinity/>
	      </m:domainofapplication>
	      <m:apply>
		<m:ci type="fn">E</m:ci>
		<m:ci>ω</m:ci>
	      </m:apply>
	    </m:apply>
	    <m:ci>δ</m:ci>
	  </m:apply>
	</m:math> and minimize over <m:math><m:ci>M</m:ci></m:math>
	and <m:math><m:ci type="vector">h</m:ci></m:math>; however,
	the design techniques minimize
	<m:math><m:ci>δ</m:ci></m:math> for a given
	<m:math><m:ci>M</m:ci></m:math>. One then repeats the design
	procedure for different <m:math><m:ci>M</m:ci></m:math> until
	the minimum <m:math><m:ci>M</m:ci></m:math> satisfying the
	requirements is found.
      </note>

	We will discuss in detail the design only of odd-length
	symmetric linear-phase FIR filters.  Even-length and
	anti-symmetric linear phase FIR filters are essentially the
	same except for a slightly different implicit weighting
	function.  For arbitrary phase, exactly optimal design
	procedures have only recently been developed (1990).
      </para>
      
    </section>
    <section id="section4">
      <title>Outline of L-∞ Filter Design</title>
      <para id="element-611">The Parks-McClellan method adopts an indirect method for finding the
minimax-optimal filter coefficients.</para><list id="list1" list-type="enumerated"><item>Using results from Approximation Theory, simple
	conditions for determining whether a given filter is
	  <m:math>
	    <m:ci>
	      <m:msup>
		<m:mi>L</m:mi>
		<m:mi>∞</m:mi>
	      </m:msup>
	    </m:ci>
	  </m:math>
	  (minimax) optimal are found.
	</item>
	<item>An iterative method for finding a filter which
	  satisfies these conditions (and which is thus optimal) is
	  developed.
	</item>
      </list>
      <para id="para8">
	That is, the 
	<m:math>
	  <m:ci>
	    <m:msup>
	      <m:mi>L</m:mi>
	      <m:mi>∞</m:mi>
	    </m:msup>
	  </m:ci>
	</m:math> filter design problem is actually solved
	<emphasis>indirectly</emphasis>.
      </para>
    </section>
    <section id="section5">
      <title>Conditions for L-∞ Optimality of a Linear-phase FIR
      Filter</title>
      <para id="para9">
	All conditions are based on Chebyshev's "Alternation Theorem,"
	a mathematical fact from polynomial approximation theory.
      </para>
      <section id="section6">
	<title>Alternation Theorem</title>
	<para id="para10">
	  Let <m:math><m:ci type="set">F</m:ci></m:math> be a compact subset on the real axis
	  <m:math><m:ci>x</m:ci></m:math>, and let
	  <m:math>
	    <m:apply>
	      <m:ci type="fn">P</m:ci>
	      <m:ci>x</m:ci>
	    </m:apply>
	  </m:math>
	  be and <m:math><m:ci>L</m:ci></m:math>th-order polynomial
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:apply>
		<m:ci type="fn">P</m:ci>
		<m:ci>x</m:ci>
	      </m:apply>
	      <m:apply>
		<m:sum/>
		<m:bvar>
		  <m:ci>k</m:ci>
		</m:bvar>
		<m:uplimit>
		  <m:ci>L</m:ci>
		</m:uplimit>
		<m:lowlimit>
		  <m:cn>0</m:cn>
		</m:lowlimit>
		<m:apply>
		  <m:times/>
		  <m:ci>
		    <m:msub>
		      <m:mi>a</m:mi>
		      <m:mi>k</m:mi>
		    </m:msub>
		  </m:ci>
		  <m:apply>
		    <m:power/>
		    <m:ci>x</m:ci>
		    <m:ci>k</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:math>
	  Also, let
	  <m:math>
	    <m:apply>
	      <m:ci type="fn">D</m:ci>
	      <m:ci>x</m:ci>
	    </m:apply>
	  </m:math>
	  be a desired function of <m:math><m:ci>x</m:ci></m:math>
	  that is continuous on <m:math><m:ci type="set">F</m:ci></m:math>, and 
	  <m:math>
	    <m:apply>
	      <m:ci type="fn">W</m:ci>
	      <m:ci>x</m:ci>
	    </m:apply>
	  </m:math> 
	  a positive, continuous weighting function on
	  <m:math><m:ci type="set">F</m:ci></m:math>.  Define the error 
	  <m:math>
	    <m:apply>
	      <m:ci type="fn">E</m:ci>
	      <m:ci>x</m:ci>
	    </m:apply>
	  </m:math>
	  on <m:math><m:ci type="set">F</m:ci></m:math> as
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:apply>
		<m:ci type="fn">E</m:ci>
		<m:ci>x</m:ci>
	      </m:apply>
	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:ci type="fn">W</m:ci>
		  <m:ci>x</m:ci>
		</m:apply>
		<m:apply>
		  <m:minus/>
		  <m:apply>
		    <m:ci type="fn">D</m:ci>
		    <m:ci>x</m:ci>
		  </m:apply>
		  <m:apply>
		    <m:ci type="fn">P</m:ci>
		    <m:ci>x</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:math>and
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:apply>
		<m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#norm"/>
		<m:domainofapplication>
		  <m:infinity/>
		</m:domainofapplication>
		<m:apply>
		  <m:ci type="fn">E</m:ci>
		  <m:ci>x</m:ci>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#argmax"/>
		<m:domainofapplication>
		  <m:apply>
		    <m:in/>
		    <m:ci>x</m:ci>
		    <m:ci type="set">F</m:ci>
		  </m:apply>
		</m:domainofapplication>
		<m:apply>
		  <m:abs/>
		  <m:apply>
		    <m:ci type="fn">E</m:ci>
		    <m:ci>x</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:math>
	  A necessary and sufficient condition that
	  <m:math>
	    <m:apply>
	      <m:ci type="fn">P</m:ci>
	      <m:ci>x</m:ci>
	    </m:apply>
	  </m:math> is the unique <m:math><m:ci>L</m:ci></m:math>th-order polynomial minimizing
	  <m:math>
	    <m:apply>
	      <m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#norm"/>
	      <m:domainofapplication>
		<m:infinity/>
	      </m:domainofapplication>
	      <m:apply>
		<m:ci type="fn">E</m:ci>
		<m:ci>x</m:ci>
	      </m:apply>
	    </m:apply>
	  </m:math> is that
	  <m:math>
	    <m:apply>
	      <m:ci type="fn">E</m:ci>
	      <m:ci>x</m:ci>
	    </m:apply>
	  </m:math> exhibits <emphasis>at least</emphasis> 
	  <m:math>
	    <m:apply>
	      <m:plus/>
	      <m:ci>L</m:ci>
	      <m:cn>2</m:cn>
	    </m:apply>
	  </m:math> "alternations;" that is, there must exist at least
	  <m:math>
	    <m:apply>
	      <m:plus/>
	      <m:ci>L</m:ci>
	      <m:cn>2</m:cn>
	    </m:apply>
	  </m:math> values of <m:math><m:ci>x</m:ci></m:math>,
	  <m:math>
	    <m:apply>
	      <m:in/>
	      <m:ci>
		<m:msub>
		  <m:mi>x</m:mi>
		  <m:mi>k</m:mi>
		</m:msub>
	      </m:ci>
	      <m:ci type="set">F</m:ci>
	    </m:apply>
	  </m:math>, 
	  <m:math>
	    <m:apply>
	      <m:eq/>
	      <m:ci>k</m:ci>
	      <m:list>
		<m:cn>0</m:cn>
		<m:cn>1</m:cn>
		<m:ci>…</m:ci>
		<m:apply>
		  <m:plus/>
		  <m:ci>L</m:ci>
		  <m:cn>1</m:cn>
		</m:apply>
	      </m:list>
	    </m:apply>
	  </m:math>, such that
	  <m:math>
	    <m:apply>
	      <m:lt/>
	      <m:ci>
		<m:msub>
		  <m:mi>x</m:mi>
		  <m:mn>0</m:mn>
		</m:msub>
	      </m:ci>
	      	<m:ci>
		  <m:msub>
		    <m:mi>x</m:mi>
		    <m:mn>1</m:mn>
		  </m:msub>
		</m:ci>
		
		  <m:ci>…</m:ci>
		  <m:ci>
		    <m:msub>
		      <m:ci>x</m:ci>
		      <m:mrow>
			<m:mi>L</m:mi>
			<m:mo>+</m:mo>
			<m:mn>2</m:mn>
		      </m:mrow>
		    </m:msub>
		  </m:ci>
		</m:apply>
	     
	  </m:math> and such that
	  <m:math>
	    <m:apply>
	      <m:eq/>
	      <m:apply>
		<m:ci type="fn">E</m:ci>
		<m:ci>
		  <m:msub>
		    <m:mi>x</m:mi>
		    <m:mi>k</m:mi>
		  </m:msub>
		</m:ci>
	      </m:apply>
	      <m:apply>
		<m:minus/>
		<m:apply>
		  <m:ci type="fn">E</m:ci>
		  <m:ci>
		    <m:msub>
		      <m:mi>x</m:mi>
		      <m:mrow>
			<m:mi>k</m:mi>
			<m:mo>+</m:mo>
			<m:mn>1</m:mn>
		      </m:mrow>
		    </m:msub>
		  </m:ci>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:mo>±</m:mo>
		<m:apply>
		  <m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#norm"/>
		  <m:domainofapplication>
		    <m:infinity/>
		  </m:domainofapplication>
		  <m:ci>E</m:ci>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:math>
	</para>
	<exercise id="exer15">
	  <problem id="idp10859200">
	    <para id="para20">What does this have to do with
	    linear-phase filter design?
	    </para>
	  </problem>
	  <solution id="idp6319904">
	    <para id="para21">It's the same problem! To show that,
	    consider an odd-length, symmetric linear phase filter.
	    </para>
	    <equation id="equation20">
	      <m:math display="block">
		<m:apply>
		  <m:eq/>
		  <m:apply>
		    <m:ci type="fn">H</m:ci>
		    <m:ci>ω</m:ci>
		  </m:apply>
		  <m:apply>
		    <m:sum/>
		    <m:bvar>
		      <m:ci>n</m:ci>
		    </m:bvar>
		    <m:uplimit>
		      <m:apply>
			<m:minus/>
			<m:ci>M</m:ci>
			<m:cn>1</m:cn>
		      </m:apply>
		    </m:uplimit>
		    <m:lowlimit>
		      <m:cn>0</m:cn>
		    </m:lowlimit>
		    <m:apply>
		      <m:times/>
		      <m:apply>
			<m:ci type="fn">h</m:ci>
			<m:ci>n</m:ci>
		      </m:apply>
		      <m:apply>
			<m:exp/>
			<m:apply>
			  <m:minus/>
			  <m:apply>
			    <m:times/>
			    <m:imaginaryi/>
			    <m:ci>ω</m:ci>
			    <m:ci>n</m:ci>
			  </m:apply>
			</m:apply>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:times/>
		    <m:apply>
		      <m:exp/>
		      <m:apply>
			<m:minus/>
			<m:apply>
			  <m:times/>
			  <m:imaginaryi/>
			  <m:ci>ω</m:ci>
			  <m:apply>
			    <m:divide/>
			    <m:apply>
			      <m:minus/>
			      <m:ci>M</m:ci>
			      <m:cn>1</m:cn>
			    </m:apply>
			    <m:cn>2</m:cn>
			  </m:apply>
			</m:apply>
		      </m:apply>
		    </m:apply>
		    <m:apply>
		      <m:plus/>
		      <m:apply>
			<m:ci type="fn">h</m:ci>
			<m:apply>
			  <m:divide/>
			  <m:apply>
			    <m:minus/>
			    <m:ci>M</m:ci>
			    <m:cn>1</m:cn>
			  </m:apply>
			  <m:cn>2</m:cn>
			</m:apply>
		      </m:apply>
		      <m:apply>
			<m:times/>
			<m:cn>2</m:cn>
			<m:apply>
			  <m:sum/>
			  <m:bvar>
			    <m:ci>n</m:ci>
			  </m:bvar>
			  <m:uplimit>
			    <m:ci>L</m:ci>
			  </m:uplimit>
			  <m:lowlimit>
			    <m:cn>1</m:cn>
			  </m:lowlimit>
			  <m:apply>
			    <m:times/>
			    <m:apply>
			      <m:ci type="fn">h</m:ci>
			      <m:apply>
				<m:minus/>
				<m:apply>
				  <m:divide/>
				  <m:apply>
				    <m:minus/>
				    <m:ci>M</m:ci>
				    <m:cn>1</m:cn>
				  </m:apply>
				  <m:cn>2</m:cn>
				</m:apply>
				<m:ci>n</m:ci>
			      </m:apply>
			    </m:apply>
			    <m:apply>
			      <m:cos/>
			      <m:apply>
				<m:times/>
				<m:ci>ω</m:ci>
				<m:ci>n</m:ci>
			      </m:apply>
			    </m:apply>
			  </m:apply>
			</m:apply>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:math>
	    </equation>
	    <equation id="equation21">
	      <m:math>
		<m:apply>
		  <m:eq/>
		  <m:apply>
		    <m:ci type="fn">A</m:ci>
		    <m:ci>ω</m:ci>
		  </m:apply>
		  <m:apply>
		    <m:plus/>
		    <m:apply>
		      <m:ci type="fn">h</m:ci>
		      <m:ci>L</m:ci>
		    </m:apply>
		    <m:apply>
		      <m:times/>
		      <m:cn>2</m:cn>
		      <m:apply>
			<m:sum/>
			<m:bvar>
			  <m:ci>n</m:ci>
			</m:bvar>
			<m:uplimit>
			  <m:ci>L</m:ci>
			</m:uplimit>
			<m:lowlimit>
			  <m:cn>1</m:cn>
			</m:lowlimit>
			<m:apply>
			  <m:times/>
			  <m:apply>
			    <m:ci type="fn">h</m:ci>
			    <m:apply>
			      <m:minus/>
			      <m:ci>L</m:ci>
			      <m:ci>n</m:ci>
			    </m:apply>
			  </m:apply>
			  <m:apply>
			    <m:cos/>
			    <m:apply>
			      <m:times/>
			      <m:ci>ω</m:ci>
			      <m:ci>n</m:ci>
			    </m:apply>
			  </m:apply>
			</m:apply>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:math>
	    </equation>
	    <para id="para23">
	      Where 
	      <m:math>
		<m:apply>
		  <m:mo>≐</m:mo>
		  <m:ci>L</m:ci>
		  <m:apply>
		    <m:divide/>
		    <m:apply>
		      <m:minus/>
		      <m:ci>M</m:ci>
		      <m:cn>1</m:cn>
		    </m:apply>
		    <m:cn>2</m:cn>
		  </m:apply>
		</m:apply>
	      </m:math>.
	    </para>
	    <para id="para24">Using trigonometric identities (such as 
	      <m:math>
		<m:apply>
		  <m:eq/>
		  <m:apply>
		    <m:cos/>
		    <m:apply>
		      <m:times/>
		      <m:ci>n</m:ci>
		      <m:ci>α</m:ci>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:minus/>
		    <m:apply>
		      <m:times/>
		      <m:cn>2</m:cn>
		      <m:apply>
			<m:cos/>
			<m:apply>
			  <m:times/>
			  <m:apply>
			    <m:minus/>
			    <m:ci>n</m:ci>
			    <m:cn>1</m:cn>
			  </m:apply>
			  <m:ci>α</m:ci>
			</m:apply>
		      </m:apply>
		      <m:apply>
			<m:cos/>
			<m:ci>α</m:ci>
		      </m:apply>
		    </m:apply>
		    <m:apply>
		      <m:cos/>
		      <m:apply>
			<m:times/>
			<m:apply>
			  <m:minus/>
			  <m:ci>n</m:ci>
			  <m:cn>2</m:cn>
			</m:apply>
			<m:ci>α</m:ci>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:math>), we can rewrite 
	      <m:math>
		<m:apply>
		  <m:ci type="fn">A</m:ci>
		  <m:ci>ω</m:ci>
		</m:apply>
	      </m:math> as
	      <m:math display="block">
		<m:apply>
		  <m:eq/>
		  <m:apply>
		    <m:ci type="fn">A</m:ci>
		    <m:ci>ω</m:ci>
		  </m:apply>
		  <m:apply>
		    <m:plus/>
		    <m:apply>
		      <m:ci type="fn">h</m:ci>
		      <m:ci>L</m:ci>
		    </m:apply>
		    <m:apply>
		      <m:times/>
		      <m:cn>2</m:cn>
		      <m:apply>
			<m:sum/>
			<m:bvar>
			  <m:ci>n</m:ci>
			</m:bvar>
			<m:uplimit>
			  <m:ci>L</m:ci>
			</m:uplimit>
			<m:lowlimit>
			  <m:cn>1</m:cn>
			</m:lowlimit>
			<m:apply>
			  <m:times/>
			  <m:apply>
			    <m:ci type="fn">h</m:ci>
			    <m:apply>
			      <m:minus/>
			      <m:ci>L</m:ci>
			      <m:ci>n</m:ci>
			    </m:apply>
			  </m:apply>
			  <m:apply>
			    <m:cos/>
			    <m:apply>
			      <m:times/>
			      <m:ci>ω</m:ci>
			      <m:ci>n</m:ci>
			    </m:apply>
			  </m:apply>
			</m:apply>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:sum/>
		    <m:bvar>
		      <m:ci>k</m:ci>
		    </m:bvar>
		    <m:uplimit>
		      <m:ci>L</m:ci>
		    </m:uplimit>
		    <m:lowlimit>
		      <m:cn>0</m:cn>
		    </m:lowlimit>
		    <m:apply>
		      <m:times/>
		      <m:ci>
			<m:msub>
			  <m:mi>α</m:mi>
			  <m:mi>k</m:mi>
			</m:msub>
		      </m:ci>
		      <m:apply>
			<m:power/>
			<m:apply>
			  <m:cos/>
			  <m:ci>ω</m:ci>
			</m:apply>
			<m:ci>k</m:ci>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:math> where the
	      <m:math>
		<m:ci>
		  <m:msub>
		    <m:mi>α</m:mi>
		    <m:mi>k</m:mi>
		  </m:msub>
		</m:ci>
	      </m:math> are related to the
	      <m:math>
		<m:apply>
		  <m:ci type="fn">h</m:ci>
		  <m:ci>n</m:ci>
		</m:apply>
	      </m:math> by a linear transformation.  Now, let
	      <m:math>
		<m:apply>
		  <m:eq/>
		  <m:ci>x</m:ci>
		  <m:apply>
		    <m:cos/>
		    <m:ci>ω</m:ci>
		  </m:apply>
		</m:apply>
	      </m:math>.  This is a one-to-one mapping from
	      <m:math>
		<m:apply>
		  <m:in/>
		  <m:ci>x</m:ci>
		  <m:interval>
		    <m:cn>-1</m:cn>
		    <m:cn>1</m:cn>
		  </m:interval>
		</m:apply>
	      </m:math> onto
	      <m:math>
		<m:apply>
		  <m:in/>
		  <m:ci>ω</m:ci>
		  <m:interval>
		    <m:cn>0</m:cn>
		    <m:pi/>
		  </m:interval>
		</m:apply>
	      </m:math>.
	      Thus
	      <m:math>
		<m:apply>
		  <m:ci type="fn">A</m:ci>
		  <m:ci>ω</m:ci>
		</m:apply>
	      </m:math> is an <m:math><m:ci>L</m:ci></m:math>th-order polynomial in
	      <m:math>
		<m:apply>
		  <m:eq/>
		  <m:ci>x</m:ci>
		  <m:apply>
		    <m:cos/>
		    <m:ci>ω</m:ci>
		  </m:apply>
		</m:apply>
	      </m:math>!
	    <note type="implication" id="idm266608"><label>Implication</label>The alternation theorem holds for
	    the
	      <m:math>
		<m:ci>
		  <m:msup>
		    <m:mi>L</m:mi>
		    <m:mi>∞</m:mi>
		  </m:msup>
		</m:ci>
	      </m:math> filter design problem, too!
	    </note>
            Therefore, to determine whether or not a
	      length-<m:math><m:ci>M</m:ci></m:math>, 
	      odd-length, symmetric linear-phase filter is optimal in an <m:math>
		<m:ci>
		  <m:msup>
		    <m:mi>L</m:mi>
		    <m:mi>∞</m:mi>
		  </m:msup>
		</m:ci>
	      </m:math> sense, simply count the alternations in
	      <m:math>
		<m:apply>
		  <m:eq/>
		  <m:apply>
		    <m:ci type="fn">E</m:ci><m:ci>ω</m:ci>
		  </m:apply>
		  <m:apply><m:times/>
		    <m:apply>
		      <m:ci type="fn">W</m:ci><m:ci>ω</m:ci>
		    </m:apply>
		    <m:apply><m:minus/>
		      <m:apply><m:ci type="fn"><m:msub><m:mi>A</m:mi><m:mi>d</m:mi></m:msub>
			</m:ci><m:ci>ω</m:ci></m:apply>
		      <m:apply><m:ci type="fn">A</m:ci><m:ci>ω</m:ci></m:apply>
		    </m:apply></m:apply></m:apply></m:math> in the
		      pass and stop bands. 
	      If there are <m:math><m:apply><m:eq/>
		  <m:apply><m:plus/><m:ci>L</m:ci><m:cn>2</m:cn></m:apply>
		  <m:apply><m:divide/><m:apply><m:plus/><m:ci>M</m:ci><m:cn>3</m:cn>
		    </m:apply><m:cn>2</m:cn></m:apply></m:apply></m:math> or more alternations, 
	      <m:math><m:apply><m:ci type="fn">h</m:ci><m:ci>n</m:ci></m:apply></m:math>, 
	      <m:math><m:apply><m:leq/><m:cn>0</m:cn><m:ci>n</m:ci>
		  <m:apply><m:minus/><m:ci>M</m:ci><m:cn>1</m:cn></m:apply></m:apply></m:math> 
	      is the optimal filter!</para>
	  </solution>
	</exercise>
      </section>
    </section>

    <section id="optsec">
      <title>Optimality Conditions for Even-length Symmetric
      Linear-phase Filters</title>
      <para id="opt1">For <m:math><m:ci>M</m:ci>
	</m:math> even,
	<m:math display="block">
	  <m:apply>
	    <m:eq/>
	    <m:apply>
	      <m:ci type="fn">A</m:ci>
	      <m:ci>ω</m:ci>
	    </m:apply>
	    <m:apply>
	      <m:sum/>
	      <m:bvar>
		<m:ci>n</m:ci>
	      </m:bvar>
	      <m:lowlimit>
		<m:cn>0</m:cn>
	      </m:lowlimit>
	      <m:uplimit>
		<m:ci>L</m:ci>
	      </m:uplimit>
	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:ci type="fn">h</m:ci>
		  <m:apply>
		    <m:minus/>
		    <m:ci>L</m:ci>
		    <m:ci>n</m:ci>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:cos/>
		  <m:apply>
		    <m:times/>
		    <m:ci>ω</m:ci>
		    <m:apply>
		      <m:plus/>
		      <m:ci>n</m:ci>
		      <m:apply>
			<m:divide/>
			<m:cn>1</m:cn>
			<m:cn>2</m:cn>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:math> where <m:math>
	  <m:apply>
	    <m:eq/>
	    <m:ci>L</m:ci>
	    <m:apply>
	      <m:minus/>
	      <m:apply>
		<m:divide/>
		<m:ci>M</m:ci>
		<m:cn>2</m:cn>
	      </m:apply>
	      <m:cn>1</m:cn>
	    </m:apply>
	  </m:apply>
	</m:math> Using the trigonometric identity
	<m:math>
	  <m:apply>
	    <m:eq/>
	    <m:apply>
	      <m:cos/>
	      <m:apply>
		<m:plus/>
		<m:ci>α</m:ci>
		<m:ci>β</m:ci>
	      </m:apply>
	    </m:apply>
	    <m:apply>
	      <m:plus/>
	      <m:apply>
		<m:cos/>
		<m:apply>
		  <m:minus/>
		  <m:ci>α</m:ci>
		  <m:ci>β</m:ci>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:times/>
		<m:cn>2</m:cn>
		<m:apply>
		  <m:cos/>
		  <m:ci>α</m:ci>
		</m:apply>
		<m:apply>
		  <m:cos/>
		  <m:ci>β</m:ci>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:math> to pull out the <m:math>
	  <m:apply>
	    <m:divide/>
	    <m:ci>ω</m:ci>
	    <m:cn>2</m:cn>
	  </m:apply>
	</m:math> term and then using the <link target-id="para24">other
	trig identities</link>, it can be shown that <m:math>
	  <m:apply>
	    <m:ci type="fn">A</m:ci>
	    <m:ci>ω</m:ci>
	  </m:apply>
	</m:math> can be written as
	<m:math display="block">
	  <m:apply>
	    <m:eq/>
	    <m:apply>
	      <m:ci type="fn">A</m:ci>
	      <m:ci>ω</m:ci>
	    </m:apply>
	    <m:apply>
	      <m:times/>
	      <m:apply>
		<m:cos/>
		<m:apply>
		  <m:divide/>
		  <m:ci>ω</m:ci>
		  <m:cn>2</m:cn>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:sum/>
		<m:bvar>
		  <m:ci>k</m:ci>
		</m:bvar>
		<m:lowlimit>
		  <m:cn>0</m:cn>
		</m:lowlimit>
		<m:uplimit>
		  <m:ci>L</m:ci>
		</m:uplimit>
		<m:apply>
		  <m:times/>
		  <m:ci><m:msub>
		      <m:mi>α</m:mi>
		      <m:mi>k</m:mi>
		    </m:msub></m:ci>
		  <m:apply>
		    <m:power/>
		    <m:apply>
		      <m:cos/>
		      <m:ci>ω</m:ci>
		    </m:apply>
		    <m:ci>k</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:math>
	Again, this is a polynomial in
	<m:math>
	  <m:apply>
	    <m:eq/>
	    <m:ci>x</m:ci>
	    <m:apply>
	      <m:cos/>
	      <m:ci>ω</m:ci>
	    </m:apply>
	  </m:apply>
	</m:math>, except for a weighting function out in front.
	<equation id="eqnopt">
	  <m:math>
	    <m:apply>
	      <m:eq/>
	      <m:apply>
		<m:ci type="fn">E</m:ci>
		<m:ci>ω</m:ci>
	      </m:apply>

	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:ci type="fn">W</m:ci>
		  <m:ci>ω</m:ci>
		</m:apply>
		<m:apply>
		  <m:minus/>
		  <m:apply>
		    <m:ci type="fn"><m:msub>
			<m:mi>A</m:mi>
			<m:mi>d</m:mi>
		      </m:msub></m:ci>
		    <m:ci>ω</m:ci>
		  </m:apply>
		  <m:apply>
		    <m:ci type="fn">A</m:ci>
		    <m:ci>ω</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>

	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:ci type="fn">W</m:ci>
		  <m:ci>ω</m:ci>
		</m:apply>
		<m:apply>
		  <m:minus/>
		  <m:apply>
		    <m:ci type="fn"><m:msub>
			<m:mi>A</m:mi>
			<m:mi>d</m:mi>
		      </m:msub></m:ci>
		    <m:ci>ω</m:ci>
		  </m:apply>
		  <m:apply>
		    <m:times/>
		    <m:apply>
		      <m:cos/>
		      <m:apply>
			<m:divide/>
			<m:ci>ω</m:ci>
			<m:cn>2</m:cn>
		      </m:apply>
		    </m:apply>
		    <m:apply>
		      <m:ci type="fn">P</m:ci>
		      <m:ci>ω</m:ci>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>

	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:ci type="fn">W</m:ci>
		  <m:ci>ω</m:ci>
		</m:apply>
		<m:apply>
		  <m:cos/>
		  <m:apply>
		    <m:divide/>
		    <m:ci>ω</m:ci>
		    <m:cn>2</m:cn>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:minus/>
		  <m:apply>
		    <m:divide/>
		    <m:apply>
		      <m:ci type="fn"><m:msub>
			  <m:mi>A</m:mi>
			  <m:mi>d</m:mi>
			</m:msub></m:ci>
		      <m:ci>ω</m:ci>
		    </m:apply>
		    <m:apply>
		      <m:cos/>
		      <m:apply>
			<m:divide/>
			<m:ci>ω</m:ci>
			<m:cn>2</m:cn>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:ci type="fn">P</m:ci>
		    <m:ci>ω</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:math>
	</equation>
	which implies
	<equation id="opteqn2">
	  <m:math>
	    <m:apply>
	      <m:eq/>
	      <m:apply>
		<m:ci type="fn">E</m:ci>
		<m:ci>x</m:ci>
	      </m:apply>
	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:ci type="fn"><m:msup>
		      <m:mi>W</m:mi>
		      <m:mo>'</m:mo>
		    </m:msup></m:ci>
		  <m:ci>x</m:ci>
		</m:apply>
		<m:apply>
		  <m:minus/>
		  <m:apply>
		    <m:ci type="fn"><m:msubsup>
			<m:mi>A</m:mi>
			<m:mi>d</m:mi>
			<m:mo>'</m:mo>
		      </m:msubsup></m:ci>
		    <m:ci>x</m:ci>
		  </m:apply>
		  <m:apply>
		    <m:ci type="fn">P</m:ci>
		    <m:ci>x</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:math>
	</equation>
	where
	<m:math display="block">
	  <m:apply>
	    <m:eq/>
	    <m:apply>
	      <m:ci type="fn"><m:msup>
		  <m:mi>W</m:mi>
		  <m:mo>'</m:mo>
		</m:msup></m:ci>
	      <m:ci>x</m:ci>
	    </m:apply>
	    <m:apply>
	      <m:times/>
	      <m:apply>
		<m:ci type="fn">W</m:ci>
		<m:apply>
		  <m:inverse/>
		  <m:apply>
		    <m:cos/>
		    <m:ci>x</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:cos/>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:divide/>
		    <m:cn>1</m:cn>
		    <m:cn>2</m:cn>
		  </m:apply>
		  <m:apply>
		    <m:inverse/>
		    <m:apply>
		      <m:cos/>
		      <m:ci>x</m:ci>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:math>
	and
	<m:math display="block">
	  <m:apply>
	    <m:eq/>
	    <m:apply>
	      <m:ci type="fn"><m:msubsup>
		  <m:mi>A</m:mi>
		  <m:mi>d</m:mi>
		  <m:mo>'</m:mo>
		</m:msubsup></m:ci>
	      <m:ci>x</m:ci>
	    </m:apply>
	    <m:apply>
	      <m:divide/>
	      <m:apply>
		<m:ci type="fn"><m:msub>
		    <m:mi>A</m:mi>
		    <m:mi>d</m:mi>
		  </m:msub></m:ci>
		<m:apply>
		  <m:inverse/>
		  <m:apply>
		    <m:cos/>
		    <m:ci>x</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:cos/>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:divide/>
		    <m:cn>1</m:cn>
		    <m:cn>2</m:cn>
		  </m:apply>
		  <m:apply>
		    <m:inverse/>
		    <m:apply>
		      <m:cos/>
		      <m:ci>x</m:ci>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:math>

	Again, this is a polynomial approximation problem, so the
	alternation theorem holds. If <m:math>
	  <m:apply>
	    <m:ci type="fn">E</m:ci>
	    <m:ci>ω</m:ci>
	  </m:apply>
	</m:math> has at least
	<m:math>
	  <m:apply>
	    <m:eq/>
	    <m:apply>
	      <m:plus/>
	      <m:ci>L</m:ci>
	      <m:cn>2</m:cn>
	    </m:apply>
	    <m:apply>
	      <m:plus/>
	      <m:apply>
		<m:divide/>
		<m:ci>M</m:ci>
		<m:cn>2</m:cn>
	      </m:apply>
	      <m:cn>1</m:cn>
	    </m:apply>
	  </m:apply>
	</m:math> alternations, the even-length symmetric filter is
	optimal in an <m:math>
	    <m:ci>
	      <m:msup>
		<m:mi>L</m:mi>
		<m:mi>∞</m:mi>
	      </m:msup>
	    </m:ci>
	  </m:math> sense.</para>
      <para id="opt3">The prototypical filter design problem:
	<m:math display="block">
	  <m:apply>
	    <m:eq/>
	    <m:ci type="fn">W</m:ci>
	    <m:piecewise>
	      <m:piece>
		<m:cn>1</m:cn>
		<m:apply>
		  <m:leq/>
		  <m:apply>
		    <m:abs/>
		    <m:ci>ω</m:ci>
		  </m:apply>
		  <m:ci><m:msub>
		      <m:mi>ω</m:mi>
		      <m:mi>p</m:mi>
		    </m:msub></m:ci>
		</m:apply>
	      </m:piece>
	      <m:piece>
		<m:apply>
		  <m:divide/>
		  <m:ci><m:msub>
		      <m:mi>δ</m:mi>
		      <m:mi>s</m:mi>
		    </m:msub></m:ci>
		  <m:ci><m:msub>
		      <m:mi>δ</m:mi>
		      <m:mi>p</m:mi>
		    </m:msub></m:ci>
		</m:apply>
		<m:apply>
		  <m:leq/>
		  <m:apply>
		    <m:abs/>
		    <m:ci><m:msub>
			<m:mi>ω</m:mi>
			<m:mi>s</m:mi>
		      </m:msub></m:ci>
		  </m:apply>
		  <m:apply>
		    <m:abs/>
		    <m:ci>ω</m:ci>
		  </m:apply>
		</m:apply>
	      </m:piece>
	    </m:piecewise>
	  </m:apply>
	</m:math> See <link target-id="fig2"/>.
      </para>

      <figure id="fig2">
	<media id="idp10807456" alt=""><image src="../../media/fig2.png" mime-type="image/png"/><image for="pdf" src="../../media/fig2.eps" mime-type="application/postscript"/></media>
      </figure>
    </section>

    <section id="optlemma">
      <title>L-∞ Optimal Lowpass Filter Design Lemma</title>
      <para id="lem1">
	<list id="lemmalist" list-type="enumerated">
	  <item>The maximum possible number of alternations for a
	  lowpass filter is
	    <m:math>
	      <m:apply>
		<m:plus/>
		<m:ci>L</m:ci>
		<m:cn>3</m:cn>
	      </m:apply>
	    </m:math>: The proof is that the extrema of a polynomial
	    occur only where the derivative is zero:
	    <m:math>
	      <m:apply>
		<m:eq/>
		<m:apply>
		  <m:partialdiff/>
		  <m:bvar>
		    <m:ci>x</m:ci>
		  </m:bvar>
		  <m:apply>
		    <m:ci type="fn">P</m:ci>
		    <m:ci>x</m:ci>
		  </m:apply>
		</m:apply>
		<m:cn>0</m:cn>
	      </m:apply>
	    </m:math>. Since
	    <m:math>
	      <m:apply>
		<m:diff/>
		<m:apply>
		  <m:ci type="fn">P</m:ci>
		  <m:ci>x</m:ci>
		</m:apply>
	      </m:apply>
	    </m:math> is an 
	    <m:math>
	      <m:mrow>
		<m:mo>(</m:mo>
		<m:mi>L</m:mi>
		<m:mo>-</m:mo>
		<m:mn>1</m:mn>
		<m:mo>)</m:mo>
	      </m:mrow>
	    </m:math>th-order polynomial, it can have at
	    <emphasis>most</emphasis>  <m:math>
	      <m:mrow>
		<m:mi>L</m:mi>
		<m:mo>-</m:mo>
		<m:mn>1</m:mn>
	      </m:mrow>
	    </m:math> zeros. <emphasis>However</emphasis>, the mapping
	    <m:math>
	      <m:apply>
		<m:eq/>
		<m:ci>x</m:ci>
		<m:apply>
		  <m:cos/>
		  <m:ci>ω</m:ci>
		</m:apply>
	      </m:apply>
	    </m:math> implies that
	    <m:math>
	      <m:apply>
		<m:eq/>
		<m:apply>
		  <m:partialdiff/>
		  <m:bvar>
		    <m:ci>ω</m:ci>
		  </m:bvar>
		  <m:apply>
		    <m:ci type="fn">A</m:ci>
		    <m:ci>ω</m:ci>
		  </m:apply>
		</m:apply>
		<m:cn>0</m:cn>
	      </m:apply>
	    </m:math> at 
	    <m:math>
	      <m:apply>
		<m:eq/>
		<m:ci>ω</m:ci>
		<m:cn>0</m:cn>
	      </m:apply>
	    </m:math> and <m:math>
	      <m:apply>
		<m:eq/>
		<m:ci>ω</m:ci>
		<m:pi/>
	      </m:apply>
	    </m:math>, for two more possible alternation
	    points. <emphasis>Finally</emphasis>, the band edges can
	    also be alternations, for a total of
	    <m:math>
	      <m:apply>
		<m:eq/>
		<m:apply>
		  <m:plus/>
		  <m:apply>
		    <m:minus/>
		    <m:ci>L</m:ci>
		    <m:cn>1</m:cn>
		  </m:apply>
		  <m:cn>2</m:cn>
		  <m:cn>2</m:cn>
		</m:apply>
		<m:apply>
		  <m:plus/>
		  <m:ci>L</m:ci>
		  <m:cn>3</m:cn>
		</m:apply>
	      </m:apply>
	    </m:math> possible alternations.</item>
	  <item>There must be an alternation at either
	    <m:math>
	      <m:apply>
		<m:eq/>
		<m:ci>ω</m:ci>
		<m:cn>0</m:cn>
	      </m:apply>
	    </m:math> or <m:math>
	      <m:apply>
		<m:eq/>
		<m:ci>ω</m:ci>
		<m:pi/>
	      </m:apply>
	    </m:math>.</item>
	  <item>Alternations must occur at
	    <m:math>
	      <m:ci><m:msub>
		  <m:mi>ω</m:mi>
		  <m:mi>p</m:mi>
		</m:msub></m:ci>
	    </m:math> and  <m:math>
	      <m:ci><m:msub>
		  <m:mi>ω</m:mi>
		  <m:mi>s</m:mi>
		</m:msub></m:ci>
	    </m:math>. See <link target-id="fig2"/>.</item>
	  <item>The filter must be equiripple except at possibly <m:math>
	      <m:apply>
		<m:eq/>
		<m:ci>ω</m:ci>
		<m:cn>0</m:cn>
	      </m:apply>
	    </m:math> or <m:math>
	      <m:apply>
		<m:eq/>
		<m:ci>ω</m:ci>
		<m:pi/>
	      </m:apply>
	    </m:math>. Again see <link target-id="fig2"/>.</item>
	</list>
	<note id="idp7813152">The alternation theorem doesn't directly suggest a
	method for computing the optimal filter. It simply tells us
	how to recognize that a filter <emphasis>is</emphasis>
	optimal, or <emphasis>isn't</emphasis> optimal. What we need
	is an intelligent way of guessing the optimal filter
	coefficients.</note>
	In matrix form, these
	<m:math>
	  <m:apply>
	    <m:plus/>
	    <m:ci>L</m:ci>
	    <m:cn>2</m:cn>
	  </m:apply>
	</m:math> simultaneous equations become
	<m:math display="block">
	  <m:apply>
	    <m:eq/>
	    <m:apply>
	      <m:times/>
	      <m:matrix>
		<m:matrixrow>
		  <m:cn>1</m:cn>
		  <m:apply>
		    <m:cos/>
		    <m:ci><m:msub>
			<m:mi>ω</m:mi>
			<m:mn>0</m:mn>
		      </m:msub></m:ci>
		  </m:apply>
		  <m:apply>
		    <m:cos/>
		    <m:apply>
		      <m:times/>
		      <m:cn>2</m:cn>
		      <m:ci><m:msub>
			  <m:mi>ω</m:mi>
			  <m:mn>0</m:mn>
			</m:msub></m:ci>
		    </m:apply>
		  </m:apply>
		  <m:ci>...</m:ci>
		  <m:apply>
		    <m:cos/>
		    <m:apply>
		      <m:times/>
		      <m:ci>L</m:ci>
		      <m:ci><m:msub>
			  <m:mi>ω</m:mi>
			  <m:mn>0</m:mn>
			</m:msub></m:ci>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:divide/>
		    <m:cn>1</m:cn>
		    <m:apply>
		      <m:ci type="fn">W</m:ci>
		      <m:ci><m:msub>
			  <m:mi>ω</m:mi>
			  <m:mn>0</m:mn>
			</m:msub></m:ci>
		    </m:apply>
		  </m:apply>
		</m:matrixrow>
		<m:matrixrow>
		  <m:cn>1</m:cn>
		  <m:apply>
		    <m:cos/>
		    <m:ci><m:msub>
			<m:mi>ω</m:mi>
			<m:mn>1</m:mn>
		      </m:msub></m:ci>
		  </m:apply>
		  <m:apply>
		    <m:cos/>
		    <m:apply>
		      <m:times/>
		      <m:cn>2</m:cn>
		      <m:ci><m:msub>
			  <m:mi>ω</m:mi>
			  <m:mn>1</m:mn>
			</m:msub></m:ci>
		    </m:apply>
		  </m:apply>
		  <m:ci>...</m:ci>
		  <m:apply>
		    <m:cos/>
		    <m:apply>
		      <m:times/>
		      <m:ci>L</m:ci>
		      <m:ci><m:msub>
			  <m:mi>ω</m:mi>
			  <m:mn>1</m:mn>
			</m:msub></m:ci>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:divide/>
		    <m:cn>-1</m:cn>
		    <m:apply>
		      <m:ci type="fn">W</m:ci>
		      <m:ci><m:msub>
			  <m:mi>ω</m:mi>
			  <m:mn>1</m:mn>
			</m:msub></m:ci>
		    </m:apply>
		  </m:apply>
		</m:matrixrow>
		<m:matrixrow>
		  <m:ci>⋮</m:ci>
		  <m:ci>⋮</m:ci>
		  <m:ci>⋱</m:ci>
		  <m:ci>...</m:ci>
		  <m:ci>⋮</m:ci>
		  <m:ci>⋮</m:ci>
		</m:matrixrow>
		<m:matrixrow>
		  <m:ci>⋮</m:ci>
		  <m:ci>⋮</m:ci>
		  <m:ci>⋮</m:ci>
		  <m:ci>⋱</m:ci>
		  <m:ci>⋮</m:ci>
		  <m:ci>⋮</m:ci>
		</m:matrixrow>
		<m:matrixrow>
		  <m:ci>⋮</m:ci>
		  <m:ci>⋮</m:ci>
		  <m:ci>⋮</m:ci>
		  <m:ci>...</m:ci>
		  <m:ci>⋱</m:ci>
		  <m:ci>⋮</m:ci>
		</m:matrixrow>
		<m:matrixrow>
		  <m:cn>1</m:cn>
		  <m:apply>
		    <m:cos/>
		    <m:ci><m:msub>
			<m:mi>ω</m:mi>
			<m:mrow>
			  <m:mi>L</m:mi>
			  <m:mo>+</m:mo>
			  <m:mn>1</m:mn>
			</m:mrow>
		      </m:msub></m:ci>
		  </m:apply>
		  <m:apply>
		    <m:cos/>
		    <m:apply>
		      <m:times/>
		      <m:cn>2</m:cn>
		      <m:ci><m:msub>
			  <m:mi>ω</m:mi>
			  <m:mrow>
			    <m:mi>L</m:mi>
			    <m:mo>+</m:mo>
			    <m:mn>1</m:mn>
			  </m:mrow>
			</m:msub></m:ci>
		    </m:apply>
		  </m:apply>
		  <m:ci>...</m:ci>
		  <m:apply>
		    <m:cos/>
		    <m:apply>
		      <m:times/>
		      <m:ci>L</m:ci>
		      <m:ci><m:msub>
			  <m:mi>ω</m:mi>
			  <m:mrow>
			    <m:mi>L</m:mi>
			    <m:mo>+</m:mo>
			    <m:mn>1</m:mn>
			  </m:mrow>
			</m:msub></m:ci>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:divide/>
		    <m:apply>
		      <m:ci><m:mo>±</m:mo></m:ci>
		      <m:cn>1</m:cn>
		    </m:apply>
		    <m:apply>
		      <m:ci type="fn">W</m:ci>
		      <m:ci><m:msub>
			  <m:mi>ω</m:mi>
			  <m:mrow>
			    <m:mi>L</m:mi>
			    <m:mo>+</m:mo>
			    <m:mn>1</m:mn>
			  </m:mrow>
			</m:msub></m:ci>
		    </m:apply>
		  </m:apply>
		</m:matrixrow>
	      </m:matrix>
	      <m:vector>
		<m:apply>
		  <m:ci type="fn">h</m:ci>
		  <m:ci>L</m:ci>
		</m:apply>
		<m:apply>
		  <m:ci type="fn">h</m:ci>
		  <m:apply>
		    <m:minus/>
		    <m:ci>L</m:ci>
		    <m:cn>1</m:cn>
		  </m:apply>
		</m:apply>
		<m:ci>⋮</m:ci>
		<m:apply>
		  <m:ci type="fn">h</m:ci>
		  <m:cn>1</m:cn>
		</m:apply>
		<m:apply>
		  <m:ci type="fn">h</m:ci>
		  <m:cn>0</m:cn>
		</m:apply>
		<m:ci>δ</m:ci>
	      </m:vector>
	    </m:apply>
	    <m:vector>
	      <m:apply>
		<m:ci type="fn"><m:msub>
		    <m:mi>A</m:mi>
		    <m:mi>d</m:mi>
		  </m:msub></m:ci>
		<m:ci><m:msub>
		    <m:mi>ω</m:mi>
		    <m:mn>0</m:mn>
		  </m:msub></m:ci>
	      </m:apply>
	      <m:apply>
		<m:ci type="fn"><m:msub>
		    <m:mi>A</m:mi>
		    <m:mi>d</m:mi>
		  </m:msub></m:ci>
		<m:ci><m:msub>
		    <m:mi>ω</m:mi>
		    <m:mn>1</m:mn>
		  </m:msub></m:ci>
	      </m:apply>
	      <m:ci>⋮</m:ci>
	      <m:ci>⋮</m:ci>
	      <m:ci>⋮</m:ci>
	      <m:apply>
		<m:ci type="fn"><m:msub>
		    <m:mi>A</m:mi>
		    <m:mi>d</m:mi>
		  </m:msub></m:ci>
		<m:ci><m:msub>
		    <m:mi>ω</m:mi>
		    <m:mrow>
		      <m:mi>L</m:mi>
		      <m:mo>+</m:mo>
		      <m:mn>1</m:mn>
		    </m:mrow>
		  </m:msub></m:ci>
	      </m:apply>
	    </m:vector>
	  </m:apply>
	</m:math> or
	<m:math display="block">
	  <m:apply>
	    <m:eq/>
	    <m:apply>
	      <m:times/>
	      <m:ci type="matrix">W</m:ci>
	      <m:vector>
		<m:ci type="vector">h</m:ci>
		<m:ci>δ</m:ci>
	      </m:vector>
	    </m:apply>
	    <m:ci type="vector"><m:msub>
		<m:mi>A</m:mi>
		<m:mi>d</m:mi>
	      </m:msub></m:ci>
	  </m:apply>
	</m:math>
	So, for the given set of <m:math>
	  <m:apply>
	    <m:plus/>
	    <m:ci>L</m:ci>
	    <m:cn>2</m:cn>
	  </m:apply>
	</m:math> extremal frequencies, we can solve for <m:math>
	  <m:ci type="vector">h</m:ci>
	</m:math> and <m:math><m:ci>δ</m:ci>
	</m:math> via
	<m:math display="inline">
	  <m:apply>
	    <m:eq/>
	    <m:vector>
	      <m:ci type="vector">h</m:ci>
	      <m:ci>δ</m:ci>
	    </m:vector>
	    <m:apply>
	      <m:times/>
	      <m:apply>
		<m:inverse/>
		<m:ci type="matrix">W</m:ci>
	      </m:apply>
	      <m:ci type="vector"><m:msub>
		  <m:mi>A</m:mi>
		  <m:mi>d</m:mi>
		</m:msub></m:ci>
	    </m:apply>
	  </m:apply>
	</m:math>. Using the FFT, we can compute
	<m:math>
	  <m:apply>
	    <m:ci type="fn">A</m:ci>
	    <m:ci>ω</m:ci>
	  </m:apply>
	</m:math> of 
	<m:math>
	  <m:apply>
	    <m:ci type="fn">h</m:ci>
	    <m:ci>n</m:ci>
	  </m:apply>
	</m:math>, on a dense set of frequencies. If the old
	<m:math>
	  <m:msub>
	    <m:mi>ω</m:mi>
	    <m:mi>k</m:mi>
	  </m:msub>
	</m:math> are, in fact the extremal locations of <m:math>
	  <m:apply>
	    <m:ci type="fn">A</m:ci>
	    <m:ci>ω</m:ci>
	  </m:apply>
	</m:math>, then the alternation theorem is satisfied and
	<m:math>
	  <m:apply>
	    <m:ci type="fn">h</m:ci>
	    <m:ci>n</m:ci>
	  </m:apply>
	</m:math> is <term>optimal</term>. If not, repeat the process
	with the new extremal locations.</para>
    </section>
    
    <section id="cost">
      <title>Computational Cost</title>
      <para id="costp"><m:math>
	  <m:apply>
	    <m:ci type="fn">O</m:ci>
	    <m:apply>
	      <m:power/>
	      <m:ci>L</m:ci>
	      <m:cn>3</m:cn>
	    </m:apply>
	  </m:apply>
	</m:math> for the matrix inverse and
	<m:math>
	  <m:apply>
	    <m:times/>
	    <m:ci>N</m:ci>
	    <m:apply>
	      <m:log/>
	      <m:logbase>
		<m:cn>2</m:cn>
	      </m:logbase>
	      <m:ci>N</m:ci>
	    </m:apply>
	  </m:apply>
	</m:math> for the FFT (<m:math>
	  <m:apply>
	    <m:geq/>
	    <m:ci>N</m:ci>
	    <m:apply>
	      <m:times/>
	      <m:cn>32</m:cn>
	      <m:ci>L</m:ci>
	    </m:apply>
	  </m:apply>
	</m:math>, typically), <emphasis>per
	iteration</emphasis>!</para>
      <para id="costp2">This method is expensive computationally due
	to the matrix inverse.</para>
      <para id="costp3">A more efficient variation of this method was
	developed by Parks and McClellan (1972), and is based on the
	Remez exchange algorithm. To understand the Remez exchange
	algorithm, we first need to understand <link document="m1">Lagrange Interpoloation</link>.</para>
    </section>

    <para id="pnext">Now <m:math>
	<m:apply>
	  <m:ci type="fn">A</m:ci>
	  <m:ci>ω</m:ci>
	</m:apply>
      </m:math> is an <m:math><m:ci>L</m:ci>
      </m:math>th-order polynomial in 
      <m:math>
	<m:apply>
	  <m:eq/>
	  <m:ci>x</m:ci>
	  <m:apply>
	    <m:cos/>
	    <m:ci>ω</m:ci>
	  </m:apply>
	</m:apply>
      </m:math>, so Lagrange interpolation can be used to
      <emphasis>exactly</emphasis> compute <m:math>
	<m:apply>
	  <m:ci type="fn">A</m:ci>
	  <m:ci>ω</m:ci>
	</m:apply>
      </m:math> from <m:math>
	<m:apply>
	  <m:plus/>
	  <m:ci>L</m:ci>
	  <m:cn>1</m:cn>
	</m:apply>
      </m:math> samples of
      <m:math>
	<m:apply>
	  <m:ci type="fn">A</m:ci>
	  <m:ci><m:msub>
	      <m:mi>ω</m:mi>
	      <m:mi>k</m:mi>
	    </m:msub></m:ci>
	</m:apply>
      </m:math>,
      <m:math>
	<m:apply>
	  <m:eq/>
	  <m:ci>k</m:ci>
	  <m:list>
	    <m:cn>0</m:cn>
	    <m:cn>1</m:cn>
	    <m:cn>2</m:cn>
	    <m:ci>...</m:ci>
	    <m:ci>L</m:ci>
	  </m:list>
	</m:apply>
      </m:math>.</para>
    <para id="pnext2">Thus, given a set of extremal frequencies and
    knowing <m:math><m:ci>δ</m:ci>
      </m:math>, samples of the amplitude response
      <m:math>
	<m:apply>
	  <m:ci type="fn">A</m:ci>
	  <m:ci>ω</m:ci>
	</m:apply>
      </m:math> can be computed <emphasis>directly</emphasis> from the
      <equation id="smile">
	<m:math>
	  <m:apply>
	    <m:eq/>
	    <m:apply>
	      <m:ci type="fn">A</m:ci>
	      <m:ci><m:msub>
		  <m:mi>ω</m:mi>
		  <m:mi>k</m:mi>
		</m:msub></m:ci>
	    </m:apply>
	    <m:apply>
	      <m:plus/>
	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:divide/>
		  <m:apply>
		    <m:power/>
		    <m:apply>
		      <m:minus/>
		      <m:cn>1</m:cn>
		    </m:apply>
		    <m:apply>
		      <m:times/>
		      <m:ci>k</m:ci>
		      <m:apply>
			<m:plus/>
			<m:cn>1</m:cn>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:ci type="fn">W</m:ci>
		    <m:ci><m:msub>
			<m:mi>ω</m:mi>
			<m:mi>k</m:mi>
		      </m:msub></m:ci>
		  </m:apply>
		</m:apply>
		<m:ci>δ</m:ci>
	      </m:apply>
	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:ci type="fn"><m:msub>
		      <m:mi>A</m:mi>
		      <m:mi>d</m:mi>
		    </m:msub></m:ci>
		  <m:ci><m:msub>
		      <m:mi>ω</m:mi>
		      <m:mi>k</m:mi>
		    </m:msub></m:ci>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:math>
      </equation>
      <emphasis>without</emphasis> solving for the filter
      coefficients!</para> 
    <para id="pnext3">This leads to computational savings!</para>
    <para id="pnext4">Note that <link target-id="smile"/> is a set of
      <m:math>
	<m:apply>
	  <m:plus/>
	  <m:ci>L</m:ci>
	  <m:cn>2</m:cn>
	</m:apply>
      </m:math> simultaneous equations, which can be solved for
      <m:math>
	<m:ci>δ</m:ci>
      </m:math> to obtain (Rabiner, 1975)
      <equation id="oface">
	<m:math>
	  <m:apply>
	    <m:eq/>
	    <m:ci>δ</m:ci>
	    <m:apply>
	      <m:divide/>
	      <m:apply>
		<m:sum/>
		<m:bvar>
		  <m:ci>k</m:ci>
		</m:bvar>
		<m:lowlimit>
		  <m:cn>0</m:cn>
		</m:lowlimit>
		<m:uplimit>
		  <m:apply>
		    <m:plus/>
		    <m:ci>L</m:ci>
		    <m:cn>1</m:cn>
		  </m:apply>
		</m:uplimit>
		<m:apply>
		  <m:times/>
		  <m:ci><m:msub>
		      <m:mi>γ</m:mi>
		      <m:mi>k</m:mi>
		    </m:msub></m:ci>
		  <m:apply>
		    <m:ci type="fn"><m:msub>
			<m:mi>A</m:mi>
			<m:mi>d</m:mi>
		      </m:msub></m:ci>
		    <m:ci><m:msub>
			<m:mi>ω</m:mi>
			<m:mi>k</m:mi>
		      </m:msub></m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:sum/>
		<m:bvar>
		  <m:ci>k</m:ci>
		</m:bvar>
		<m:lowlimit>
		  <m:cn>0</m:cn>
		</m:lowlimit>
		<m:uplimit>
		  <m:apply>
		    <m:plus/>
		    <m:ci>L</m:ci>
		    <m:cn>1</m:cn>
		  </m:apply>
		</m:uplimit>
		<m:apply>
		  <m:divide/>
		  <m:apply>
		    <m:times/>
		    <m:apply>
		      <m:power/>
		      <m:apply>
			<m:minus/>
			<m:cn>1</m:cn>
		      </m:apply>
		      <m:apply>
			<m:times/>
			<m:ci>k</m:ci>
			<m:apply>
			  <m:plus/>
			  <m:cn>1</m:cn>
			</m:apply>
		      </m:apply>
		    </m:apply>
		    <m:ci><m:msub>
			<m:mi>γ</m:mi>
			<m:mi>k</m:mi>
		      </m:msub></m:ci>
		  </m:apply>
		  <m:apply>
		    <m:ci type="fn">W</m:ci>
		    <m:ci><m:msub>
			<m:mi>ω</m:mi>
			<m:mi>k</m:mi>
		      </m:msub></m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:math>
      </equation>
      where
      <m:math display="block">
	<m:apply>
	  <m:eq/>
	  <m:ci><m:msub>
	      <m:mi>γ</m:mi>
	      <m:mi>k</m:mi>
	    </m:msub></m:ci>
	  <m:apply>
	    <m:product/>
	    <m:bvar>
	      <m:ci>i</m:ci>
	    </m:bvar>
	    <m:condition>
	      <m:apply>
		<m:neq/>
		<m:ci>i</m:ci>
		<m:ci>k</m:ci>
	      </m:apply>
	    </m:condition>
	    <m:lowlimit>
	      <m:cn>0</m:cn>
	    </m:lowlimit>
	    <m:uplimit>
	      <m:apply>
		<m:plus/>
		<m:ci>L</m:ci>
		<m:cn>1</m:cn>
	      </m:apply>
	    </m:uplimit>
	    <m:apply>
	      <m:divide/>
	      <m:cn>1</m:cn>
	      <m:apply>
		<m:minus/>
		<m:apply>
		  <m:cos/>
		  <m:ci><m:msub>
		      <m:mi>ω</m:mi>
		      <m:mi>k</m:mi>
		    </m:msub></m:ci>
		</m:apply>
		<m:apply>
		  <m:cos/>
		  <m:ci><m:msub>
		      <m:mi>ω</m:mi>
		      <m:mi>i</m:mi>
		    </m:msub></m:ci>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:apply>
      </m:math>
      The result is the Parks-McClellan FIR filter design method,
      which is simply an application of the Remez exchange algorithm
      to the filter design problem. See <link target-id="fig3"/>.
    </para>

    <figure id="fig3">
      <media id="idp7289008" alt=""><image src="../../media/fig3.png" mime-type="image/png"/><image for="pdf" src="../../media/fig3.eps" mime-type="application/postscript"/></media>
      <caption>The initial guess of extremal frequencies is usually
      equally spaced in the band. Computing <m:math>
	  <m:ci>δ</m:ci>
	</m:math> costs <m:math>
	<m:apply>
	  <m:ci type="fn">O</m:ci>
	  <m:apply>
	    <m:power/>
	    <m:ci>L</m:ci>
	    <m:cn>2</m:cn>
	  </m:apply>
	</m:apply>
      </m:math>. Using Lagrange interpolation costs
	<m:math>
	  <m:apply>
	    <m:approx/>
	    <m:apply>
	      <m:ci type="fn">O</m:ci>
	      <m:apply>
		<m:times/>
		<m:cn>16</m:cn>
		<m:ci>L</m:ci>
		<m:ci>L</m:ci>
	      </m:apply>
	    </m:apply>
	    <m:apply>
	      <m:ci type="fn">O</m:ci>
	      <m:apply>
		<m:times/>
		<m:cn>16</m:cn>
		<m:apply>
		  <m:power/>
		  <m:ci>L</m:ci>
		  <m:cn>2</m:cn>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:math>. Computing <m:math>
	  <m:apply>
	    <m:ci type="fn">h</m:ci>
	    <m:ci>n</m:ci>
	  </m:apply>
	</m:math> costs <m:math>
	<m:apply>
	  <m:ci type="fn">O</m:ci>
	  <m:apply>
	    <m:power/>
	    <m:ci>L</m:ci>
	    <m:cn>3</m:cn>
	  </m:apply>
	</m:apply>
      </m:math>, but it is only done once!</caption>
    </figure>
    
    <para id="lastp">The cost per iteration is 
      <m:math>
	<m:apply>
	  <m:ci type="fn">O</m:ci>
	  <m:apply>
	    <m:times/>
	    <m:cn>16</m:cn>
	    <m:apply>
	      <m:power/>
	      <m:ci>L</m:ci>
	      <m:cn>2</m:cn>
	    </m:apply>
	  </m:apply>
	</m:apply>
      </m:math>, as opposed to 
      <m:math>
	<m:apply>
	  <m:ci type="fn">O</m:ci>
	  <m:apply>
	    <m:power/>
	    <m:ci>L</m:ci>
	    <m:cn>3</m:cn>
	  </m:apply>
	</m:apply>
      </m:math>; much more efficient for large <m:math><m:ci>L</m:ci>
      </m:math>. Can also interpolate to DFT sample frequencies,
      take inverse FFT to get corresponding filter coefficients, and
      zeropad and take longer FFT to efficiently interpolate.</para>

  </content>
  
</document>